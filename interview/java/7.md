## 抽象类和接口

###1、 抽象类

+ 需要使用关键字abstract声明

+ 抽象方法只需要声明，而不需要实现

+ 不能被实例化

+ 可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类

+ 具体派生类必须覆盖基类的抽象方法

+ 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们

+ 派生类继承需要用关键字 extends

  

### 2、 接口

+ 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

+ 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

  除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

+ 接口无法被实例化，但是可以被实现

+ 一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

+ 实现类实现接口需要用关键字 implements

### 3、 对比

#### 3.1 不同点

| 参数               | 抽象类                                                       | 接口                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 构造器             | 有                                                           | 无                                                           |
| 实现               | 子类使用extends关键字来继承，若子类不是抽象类，需要提供抽象类中所以声明的方法的实现 | 子类使用implements关键字来实现接口，并且需要实现接口中所有声明的方法 |
| 与正常java类的区别 | 除了不能实例化抽象类之外，与普通java类没有区别               | 类型不同                                                     |
| 方法访问修饰符     | public、protected、default                                   | 默认为public  缺省                                           |
| 静态方法           | 可以有                                                       | 无                                                           |
| 普通类             | 单一继承                                                     | 多重实现                                                     |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |

##### 3.2 相同点：

+ 不能被直接实例化
+ 都可以包含方法声明
+  派生类必须实现未实现的方法

### 4<u>使用场景</u>

+ 如果拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 
+ 如果想实现多重继承，那么必须使用接口。由于Java不支持多继承，即一个类只能有一个超类。但是，可以实现多个接口，因此可以使用接口来解决它。 
+ 如果基本功能在不断改变，那么就需要使用抽象类，达到解耦目的。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。
+   接口更多的是在系统架构设计方面发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用。

##### ex:

**以下内容来自：**<https://www.cnblogs.com/east7/p/10739789.html>

门和警报——门都有open( )和close( )两个动作，通过抽象类和接口来定义这个抽象概念。  

```java
abstract class Door {
    public abstract void open();
    public abstract void close();
}
```

或者

```java
interface Door {
    void open();
	void close();
}
```

但是现在如果需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：

+ 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；
+ 将这三个功能都放在接口里面，需要用到报警功能的类就实现接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )功能，比如火灾报警器。

从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身**固有的行为特性**，而alarm()属于延伸的**附加行为**。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

```java
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

###5、问与答 

Q1：接口是否可继承接口?

答：接口可以继承接口。

 

Q2：抽象类是否可实现(implements)接口?

答：抽象类可以实现接口。

 

Q3：抽象类是否可继承实体类(concrete class)?

答：抽象类可以继承实体类。

 

Q4：抽象类中是否可以有静态的main方法？

答：抽象类中可以有静态的main方法。

 

Q5：抽象类与普通类的区别是？

答：二者的区别就是①不能创建实例对象，②允许有abstract方法。也可以这么理解——抽象类就是一个不能实例化的普通类，不过如果方法加了abstract，那么就必须在子类里面重写。

 

Q6：抽象类为什么不能实例化对象？

答：现实生活中也有抽象类的例子，比如说人类是一个抽象类，我们无法创建一个称作人类的对象，但是，人可以在继承人类后来创建对象。况且抽象类中的抽象方法只有声明，是未实现的方法，如果实例化了，又如何去实现方法调用呢？

 

Q7：abstract和final能否共用？

答：抽象类需要被继承才能使用，而被final修饰的类无法被继承，所以abstract和final是不能共存的。

